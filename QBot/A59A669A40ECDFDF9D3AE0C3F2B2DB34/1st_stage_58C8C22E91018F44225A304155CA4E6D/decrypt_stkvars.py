import binascii
import idautils

# ida_ua: https://hex-rays.com/products/ida/support/idapython_docs/ida_ua.html

file = open("x_EncryptedBuffer.bin", "rb")
encrypted_buffer = file.read()


key_buff = open("x_Key.bin", "rb")
key = key_buff.read()
#key = binascii.unhexlify("3B7397BE28A1C5F978B59AB2051D03958DF21305135685E5460321F2A9E6606065A8F68BE82962667C5FEB26A23B607EA9220EA63E6F5F043DF1ECACB21F18690000000000000000")

insn = ida_ua.insn_t()

def get_prev_insn(insn, ea_insn):
	
	prev_ea_insn = ida_ua.decode_prev_insn(insn, ea_insn)
	insn_len = ida_ua.decode_insn(insn, prev_ea_insn)
	return insn

def get_next_insn(insn, ea_insn):

	insn_len = ida_ua.decode_insn(insn, ea_insn)
	nex_ea = ea_insn + insn_len
	next_insn = ida_ua.decode_insn(insn, nex_ea)
	return insn

def get_stkvar_value(func_ea):
	'''
	use FlowChart to get a flow of basic blocks and only parse the first block
	using start_ea, end_ea as range
	eg: function (4035fb) 
		id: 0, startEA: 4035fb, endEA: 4036b6


	check if initialized stkvar
	mov	[ebp + var_x], o_imm
	o_imm not [0 | ffffffff]
	'''
	function = idaapi.get_func(func_ea)
	bblocks = idaapi.FlowChart(function)

	start_ea = bblocks[0].start_ea
	end_ea = bblocks[0].end_ea

	# ida_ua.decode_insn(insn, ea)

	stkvars = []
	stkvars_ea = []

	ida_ua.decode_insn(insn, start_ea)
	while start_ea <= end_ea:
		ida_ua.decode_insn(insn, start_ea)

		if insn.get_canon_mnem() == "mov" and insn.ops[1].type == o_imm:
			if insn.ops[1].value != 0 and hex(insn.ops[1].value) != 0xffffffff:
				# print(type(insn.ops[1].value), type(f"{(insn.ops[1].value):x}"))
				stkvars.append(insn.ops[1].value)
				stkvars_ea.append(start_ea)


		else:
			print(f"[+] not an initialized stack variable")

		start_ea = ida_bytes.next_head(start_ea, end_ea)
		# get_next_insn(insn, start_ea)
		# print(f"{insn.ops[1].value:x}h")
	return stkvars, stkvars_ea


def string_decrypt(offset):

	decrypted_string = ""
	offset_end = offset
	i = 0
	if offset < 0x373a:
		while encrypted_buffer[offset_end] != key[offset_end & 0x3F]:
			offset_end += 1
		string_size = offset_end - offset
		# print(string_size)

		while i < string_size:
			decrypted_string += chr(encrypted_buffer[offset + i] ^ key[(offset + i) & 0x3F])
			i += 1
		print(f"[DECRYPTED] 0x{offset:x}:\t{decrypted_string}")
		return decrypted_string


def set_comment(decrypted_string, xref):
	ida_bytes.set_cmt(xref, f"[+] {decrypted_string}", 0)
	# if (ida_bytes.set_cmt(xref, f"[+] {decrypted_string}", 0)):
		# print(f"comment {decrypted_string} at 0x{xref:x}")


def main():

	fn = [
	0x4035fb, 0x403C24, 0x403D67, 0x403AE5, 0x405418,
	]

	for func_ea in fn:
		stkvars, stkvars_ea = get_stkvar_value(func_ea)
		for (offset, ea) in zip(stkvars, stkvars_ea):
			# print(f"{offset:x}h at 0x{ea:x}")
			decrypted_string = string_decrypt(offset)
			set_comment(decrypted_string, ea)


