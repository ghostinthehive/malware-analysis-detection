import binascii
import idautils

# key = binascii.unhexlify("3B7397BE28A1C5F978B59AB2051D03958DF21305135685E5460321F2A9E6606065A8F68BE82962667C5FEB26A23B607EA9220EA63E6F5F043DF1ECACB21F18690000000000000000")

file = open("EncryptedBuffer.bin", "rb")
encrypted_buffer = file.read()


key_buff = open("Key.bin", "rb")
key = key_buff.read()

def get_xrefs(fn):
	xrefs = []
	number_of_xrefs = 0
	for xref in idautils.XrefsTo(fn):
		xrefs.append(xref.frm)
		number_of_xrefs += 1
	print(f"locating {number_of_xrefs} XrefsTo for function: 0x{fn:x}")
	return xrefs


def fetch_offsets(xref, func_addr):

	offset = 0
	insn = ida_ua.insn_t()
	# xrefs = []
	i = 0

	prev_insn = ida_ua.decode_prev_insn(insn, xref)
	insnlen = ida_ua.decode_insn(insn, prev_insn)
	# check mnem and fetch imm_value
	if insn.get_canon_mnem() == "push":
		if insn.ops[0].type == o_imm:
			offset = insn.ops[0].value
		else:
			print(f"[WEIRD PUSH at 0x{prev_insn:x} at xref 0x{xref:x}]")
	if insn.get_canon_mnem() == "mov":
		if insn.ops[1].type == o_imm:
			offset = insn.ops[1].value

		elif insn.ops[1].type == o_reg:
			print(f"[+] MOV REG at 0x{prev_insn:x} at xref 0x{xref:x}")

			if func_addr == 0x1000ECFD:
#string_decrypt0(0x10002640) -> mov edi, o_imm
				while insn.get_canon_mnem() != "push": 
					prev_insn = ida_ua.decode_prev_insn(insn, prev_insn)
					ida_ua.decode_insn(insn, prev_insn)
					if insn.get_canon_mnem() == "push" and insn.ops[0].type == o_imm:
						offset = insn.ops[0].value
						print(f"[++++++++++] Executed 0x{func_addr:x}, offset is 0x{offset:x} at {prev_insn:x}");

						break
			if func_addr == 0x1000EC70:
				reg_displ = ""
				while print_operand(prev_insn, 0) != "edi":
					prev_insn = ida_ua.decode_prev_insn(insn, prev_insn)
					ida_ua.decode_insn(insn, prev_insn)
					if print_operand(prev_insn, 0) == "edi" and insn.ops[1].type == o_imm:
						offset = insn.ops[1].value
						print(f"---> mov edi, {offset:x}h")
						break
					if print_operand(prev_insn, 0) == "edi" and insn.ops[1].type == o_reg:
						reg_displ = print_operand(prev_insn, 1)
						prev_insn = ida_ua.decode_prev_insn(insn, prev_insn)
						ida_ua.decode_insn(insn, prev_insn)

						while print_operand(prev_insn, 0) != reg_displ: 
							prev_insn = ida_ua.decode_prev_insn(insn, prev_insn)
							ida_ua.decode_insn(insn, prev_insn)
						offset = insn.ops[1].value
						break

		else:
			print(f"MOV type {insn.ops[1].type} OTHER at 0x{prev_insn:x} at xref 0x{xref:x}")
			offset = 0
	print(f"offset 0x{offset:x} at xref 0x{xref:x} for 0x{func_addr:x}")

	return offset

def string_decrypt(offset):

	decrypted_string = ""
	offset_end = offset
	i = 0
	if offset < 0x373a:
		while encrypted_buffer[offset_end] != key[offset_end & 0x3F]:
			offset_end += 1
		string_size = offset_end - offset
		# print(string_size)

		while i < string_size:
			decrypted_string += chr(encrypted_buffer[offset + i] ^ key[(offset + i) & 0x3F])
			i += 1
		print(f"[DECRYPTED] 0x{offset:x}:\t{decrypted_string}")
		return decrypted_string

def set_comment(decrypted_string, xref):
	if (ida_bytes.set_cmt(xref, f"[+] {decrypted_string}", 0)):
		print(f"comment {decrypted_string} at 0x{xref:x}")

def main():

	decrypt_func = [0x1000EC70, 0x1000ECFD]
	for fn in decrypt_func:
		xrefs = get_xrefs(fn)
		for xref in xrefs:
			offset = fetch_offsets(xref, fn)
			decrypted_string = string_decrypt(offset)
			set_comment(decrypted_string, xref)



