import binascii
import idautils


file = open("EncryptedBuffer.bin", "rb")
encrypted_buffer = file.read()

key_buff = open("Key.bin", "rb")
key = key_buff.read()

def string_decrypt(offset):

	decrypted_string = ""
	offset_end = offset
	i = 0
	if offset < 0x373a:
		while encrypted_buffer[offset_end] != key[offset_end & 0x3F]:
			offset_end += 1
		string_size = offset_end - offset
		# print(string_size)

		while i < string_size:
			decrypted_string += chr(encrypted_buffer[offset + i] ^ key[(offset + i) & 0x3F])
			i += 1
		print(f"[DECRYPTED] 0x{offset:x}:\t{decrypted_string}")
		return decrypted_string


def iat_define(ptr_api_struct):

	ea_api = []
	offsets = []
	while ida_bytes.get_wide_dword(ptr_api_struct) != 0x00:

		# originally a handle when constructing the struct
		# then overwritten to a ptrAPI
		ea_api.append(ida_bytes.get_wide_dword(ptr_api_struct))
		ptr_api_struct = ida_bytes.next_head(ptr_api_struct, 0xffffffff)

		# offset in data[] to decrypt procname
		offsets.append(ida_bytes.get_wide_dword(ptr_api_struct))
		ptr_api_struct = ida_bytes.next_head(ptr_api_struct, 0xffffffff)

		# offset in data[] to decrypt modulename
		# needed for module validation
		offset_dll = ida_bytes.get_wide_dword(ptr_api_struct)
		ptr_api_struct = ida_bytes.next_head(ptr_api_struct, 0xffffffff)

	return ea_api, offsets

def main():

	dll_structs = [ 	
				0x100271D0, #kernel32 + others
				0x100270E0,
				0x100270A4,
				0x10027890,
				
				]
	for dll in dll_structs:
		ea_api, offsets = iat_define(dll)
		for (ea, offset) in zip(ea_api, offsets):
			decrypted_api = string_decrypt(offset)

			if not set_name(ea, decrypted_api):
				set_name(ea, f"{decrypted_api}_0")