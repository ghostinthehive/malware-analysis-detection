import binascii
import idautils

key_bin = open("x_Key.bin", "rb")
key = key_bin.read()

buff_bin = open("x_EncryptedBuffer.bin", "rb")
encrypted_buffer = buff_bin.read()

# key = binascii.unhexlify("3B7397BE28A1C5F978B59AB2051D03958DF21305135685E5460321F2A9E6606065A8F68BE82962667C5FEB26A23B607EA9220EA63E6F5F043DF1ECACB21F18690000000000000000")

def string_decrypt(offset):

	decrypted_string = ""
	offset_end = offset
	i = 0
	if offset < 0x373a:
		while encrypted_buffer[offset_end] != key[offset_end & 0x3F]:
			offset_end += 1
		string_size = offset_end - offset
		# print(string_size)

		while i < string_size:
			decrypted_string += chr(encrypted_buffer[offset + i] ^ key[(offset + i) & 0x3F])
			i += 1
		print(f"[DECRYPTED] 0x{offset:x}:\t{decrypted_string}")
		return decrypted_string


def build_hooks(struct_ea, num_of_hooks):

	api_offsets = []
	hooks_ea = []
	trampolines_ea = []
	i = 0
	while i < num_of_hooks:

		dll_offset = ida_bytes.get_wide_dword(struct_ea)
		print(f"0x{dll_offset:x}")

		api_offset_ea = ida_bytes.next_head(struct_ea, 0xffffffff)
		api_offset = ida_bytes.get_wide_dword(api_offset_ea)
		print(f"0x{api_offset:x}")
		api_offsets.append(api_offset)

		next_head = ida_bytes.next_head(api_offset_ea, 0xffffffff)
		hook_ea = ida_bytes.get_wide_dword(next_head)
		print(f"0x{hook_ea:x}")
		hooks_ea.append(hook_ea)

		next_head = ida_bytes.next_head(next_head, 0xffffffff)
		trampoline_ea = ida_bytes.get_wide_dword(next_head)
		print(f"0x{trampoline_ea:x}")
		trampolines_ea.append(trampoline_ea)

		next_head = ida_bytes.next_head(next_head, 0xffffffff)
		next_head = ida_bytes.next_head(next_head, 0xffffffff)

		struct_ea = ida_bytes.next_head(next_head, 0xffffffff)
		print(f"next member at 0x{struct_ea:x}")

		i += 1

	return api_offsets, hooks_ea, trampolines_ea


def main():

	hook_structs = [
					(0x100249F0, 10), #ws2_32.dll
					(0x100249D4, 1), #ntdll.dll
					(0x10024AC8, 4), #user32.dll
					(0x10024B20, 10), #wininet.dll
					(0x10024BF8, 8), # nss3.dll
					]
	# print(f"[!] 0x{ida_bytes.get_wide_dword(0x100249FC):x}")
	for struct in hook_structs:
		# unpack the tuple
		(struct_ea, num_of_hooks) = struct
		api_offsets, hooks_ea, trampolines_ea = build_hooks(struct_ea, num_of_hooks)

		for offset, hook_ea, trmpln_ea in zip(api_offsets, hooks_ea, trampolines_ea):
			decrypted_api = string_decrypt(offset)
			set_name(hook_ea, f"{decrypted_api}_hook")
			set_name(trmpln_ea, f"{decrypted_api}_trmpln")


'''
struct = { 
			DLL_offset,
			API_offset,
			hook_function,
			trampoline_function,
			5_bytes
		}


string_decrypt(offset_2)
set_name(f"{decrypted_string}_hook", hook_funtion)
set_name(f"{decrypted_string}_trampoline", trampoline_function)

'''