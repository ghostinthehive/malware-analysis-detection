import binascii
import idautils

# ida_ua: https://hex-rays.com/products/ida/support/idapython_docs/ida_ua.html

# key = binascii.unhexlify("3B7397BE28A1C5F978B59AB2051D03958DF21305135685E5460321F2A9E6606065A8F68BE82962667C5FEB26A23B607EA9220EA63E6F5F043DF1ECACB21F18690000000000000000")


key_bin = open("x_Key.bin", "rb")
key = key_bin.read()

buff_bin = open("x_EncryptedBuffer.bin", "rb")
encrypted_buffer = buff_bin.read()

insn = ida_ua.insn_t()


def get_prev_insn(insn, ea_insn):
	
	prev_ea_insn = ida_ua.decode_prev_insn(insn, ea_insn)
	insn_len = ida_ua.decode_insn(insn, prev_ea_insn)

	return insn

def get_next_insn(insn, ea_insn):

	insn_len = ida_ua.decode_insn(insn, ea_insn)
	nex_ea = ea_insn + insn_len
	next_insn = ida_ua.decode_insn(insn, nex_ea)

	return insn

def get_stkvar_value(func_ea):
	'''
	use FlowChart to get a flow of basic blocks and only parse the first block
	using start_ea, end_ea as range
	eg: function (4035fb) 
		id: 0, startEA: 4035fb, endEA: 4036b6


	check if initialized stkvar
	case_1:
		mov	[ebp + var_x], o_imm
		o_imm not [0 | ffffffff]
	case_2:
		mov o_reg, o_imm
		mov [o_reg + var_x], o_reg

	'''
	function = idaapi.get_func(func_ea)
	bblocks = idaapi.FlowChart(function)

	start_ea = bblocks[1].start_ea
	end_ea = bblocks[1].end_ea

	stkvars = []
	stkvars_ea = []

	ida_ua.decode_insn(insn, start_ea)
	while start_ea <= end_ea:
		ida_ua.decode_insn(insn, start_ea)

		if insn.get_canon_mnem() == "mov" and insn.ops[1].type == o_imm:
			if insn.ops[1].value != 0 and hex(insn.ops[1].value) != 0xffffffff:
				# print(type(insn.ops[1].value), type(f"{(insn.ops[1].value):x}"))
				stkvars.append(insn.ops[1].value)
				stkvars_ea.append(start_ea)

		if insn.get_canon_mnem() == "mov" and insn.ops[1].type == o_reg:
			reg_displ = print_operand(start_ea, 1)
			print(f"[!] Displacment {reg_displ} at 0x{start_ea:x}")
			prev_insn = ida_ua.decode_prev_insn(insn, start_ea)

			while prev_insn >= bblocks[1].start_ea:
				prev_insn = ida_ua.decode_prev_insn(insn, prev_insn)
				# print(print_operand(prev_insn, 0), f"{prev_insn:x}")
				if print_operand(prev_insn, 0) == reg_displ and insn.ops[1].type == o_imm:
					print(f"0x{prev_insn:x}, {print_operand(prev_insn, 1)}, 0x{insn.ops[1].value:x}")
					stkvars.append(insn.ops[1].value)
					stkvars_ea.append(start_ea)
					break
		else:
			print(f"[+] not an initialized stack variable")

		start_ea = ida_bytes.next_head(start_ea, end_ea)

	return stkvars, stkvars_ea


def string_decrypt(offset):

	decrypted_string = ""
	offset_end = offset
	i = 0
	if offset < 0x36F4:
		while encrypted_buffer[offset_end] != key[offset_end & 0x3F]:
			offset_end += 1
		string_size = offset_end - offset
		# print(string_size)

		while i < string_size:
			decrypted_string += chr(encrypted_buffer[offset + i] ^ key[(offset + i) & 0x3F])
			i += 1
		print(f"[DECRYPTED] 0x{offset:x}:\t{decrypted_string}")
		return decrypted_string


def set_comment(decrypted_string, xref):
	ida_bytes.set_cmt(xref, f"[+] {decrypted_string}", 0)
	# if (ida_bytes.set_cmt(xref, f"[+] {decrypted_string}", 0)):
		# print(f"comment {decrypted_string} at 0x{xref:x}")


def main():

# stkvar are in the second block
	fn = [
		0x1000D7C3,
	]

	for func_ea in fn:
		stkvars, stkvars_ea = get_stkvar_value(func_ea)
		for (offset, ea) in zip(stkvars, stkvars_ea):
			# print(f"{offset:x}h at 0x{ea:x}")
			decrypted_string = string_decrypt(offset)
			set_comment(decrypted_string, ea)
		# print(len(stkvars))
		# print(len(stkvars_ea))

