import binascii
import idautils

# key = binascii.unhexlify("3B7397BE28A1C5F978B59AB2051D03958DF21305135685E5460321F2A9E6606065A8F68BE82962667C5FEB26A23B607EA9220EA63E6F5F043DF1ECACB21F18690000000000000000")

key_bin = open("x_Key.bin", "rb")
key = key_bin.read()

buff_bin = open("x_EncryptedBuffer.bin", "rb")
encrypted_buffer = buff_bin.read()

def get_xrefs(fn):
	xrefs = []
	number_of_xrefs = 0
	for xref in idautils.XrefsTo(fn):
		xrefs.append(xref.frm)
		number_of_xrefs += 1
	print(f"locating {number_of_xrefs} XrefsTo for function: 0x{fn:x}")
	return xrefs


def fetch_offsets(xref, func_addr):

	offset = 0

	insn = ida_ua.insn_t()
	prev_insn = ida_ua.decode_prev_insn(insn, xref)
	insnlen = ida_ua.decode_insn(insn, prev_insn)

	while True:

		if insn.get_canon_mnem() == "push":
			if insn.ops[0].type == o_imm:
				offset = insn.ops[0].value
				break
			else:
				print(f"[!] WEIRD PUSH at 0x{prev_insn:x} at xref 0x{xref:x}]")
				continue
		if insn.get_canon_mnem() == "mov":

			# mostly string_decrypt->0x100147C5
			if insn.ops[1].type == o_imm:
				# print(f"MOV {insn.ops[1].value}")

				offset = insn.ops[1].value
				break
			if insn.ops[1].type == o_reg:
				# print(f"[+] MOV REG at 0x{prev_insn:x} at xref 0x{xref:x}")

				if func_addr == 0x100147C5:
					reg_displ = ""
					while print_operand(prev_insn, 0) != "eax":
						prev_insn = ida_ua.decode_prev_insn(insn, prev_insn)
						ida_ua.decode_insn(insn, prev_insn)
						if print_operand(prev_insn, 0) == "eax" and insn.ops[1].type == o_imm:
							offset = insn.ops[1].value
							break
						if print_operand(prev_insn, 0) == "eax" and insn.ops[1].type == o_reg:
							reg_displ = print_operand(prev_insn, 1)

							prev_insn = ida_ua.decode_prev_insn(insn, prev_insn)
							ida_ua.decode_insn(insn, prev_insn)

							while print_operand(prev_insn, 0) != reg_displ: 
								prev_insn = ida_ua.decode_prev_insn(insn, prev_insn)
								ida_ua.decode_insn(insn, prev_insn)
							offset = insn.ops[1].value
							break

			else:
				# print(f"[+] MOV type {insn.ops[1].type} OTHER at 0x{prev_insn:x} at xref 0x{xref:x}")
				print(f"[!] Failed to extract offset... at 0x{prev_insn:x}")
				offset = 0
				break
		else:
			print(f"[!] Skipping instruction...")
			prev_insn = ida_ua.decode_prev_insn(insn, prev_insn)
			ida_ua.decode_insn(insn, prev_insn)
			continue
	# print(f"offset 0x{offset:x} at xref 0x{xref:x} for 0x{func_addr:x}")

	return offset

def string_decrypt(offset):

	decrypted_string = ""
	offset_end = offset
	i = 0
	if offset < 0x36F4:
		while encrypted_buffer[offset_end] != key[offset_end & 0x3F]:
			offset_end += 1
		string_size = offset_end - offset
		# print(string_size)

		while i < string_size:
			decrypted_string += chr(encrypted_buffer[offset + i] ^ key[(offset + i) & 0x3F])
			i += 1
		if offset == 0x0:
			print(f"[DEFAULT] 0x{offset:x}:\t{decrypted_string}")
		# print(f"[DECRYPTED] 0x{offset:x}:\t{decrypted_string}")
		return decrypted_string

def set_comment(decrypted_string, xref):
	if (ida_bytes.set_cmt(xref, f"[+] {decrypted_string}", 0)):
		print(f"comment {decrypted_string} at 0x{xref:x}")

def main():

	decrypt_func = [0x100147C5, 0x10014738]
	for fn in decrypt_func:
		xrefs = get_xrefs(fn)
		for xref in xrefs:
			offset = fetch_offsets(xref, fn)
			decrypted_string = string_decrypt(offset)
			set_comment(decrypted_string, xref)

'''
string_decrypt->0x100147C5
mov	eax, o_imm [mov, o_imm]

string_decrypt0->0x10014738
mov	edi, o_imm [mov - o_imm]

'''