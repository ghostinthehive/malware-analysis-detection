import binascii
import idautils

key_bin = open("x_Key.bin", "rb")
key = key_bin.read()

buff_bin = open("x_EncryptedBuffer.bin", "rb")
encrypted_buffer = buff_bin.read()

# key = binascii.unhexlify("3B7397BE28A1C5F978B59AB2051D03958DF21305135685E5460321F2A9E6606065A8F68BE82962667C5FEB26A23B607EA9220EA63E6F5F043DF1ECACB21F18690000000000000000")

def string_decrypt(offset):

	decrypted_string = ""
	offset_end = offset
	i = 0
	if offset < 0x373a:
		while encrypted_buffer[offset_end] != key[offset_end & 0x3F]:
			offset_end += 1
		string_size = offset_end - offset
		# print(string_size)

		while i < string_size:
			decrypted_string += chr(encrypted_buffer[offset + i] ^ key[(offset + i) & 0x3F])
			i += 1
		print(f"[DECRYPTED] 0x{offset:x}:\t{decrypted_string}")
		return decrypted_string


def iat_define(ptr_api_struct):

	ea_api = []
	offsets = []
	while ida_bytes.get_wide_dword(ptr_api_struct) != 0x00:

		# originally a handle when constructing the struct
		# then overwritten to a ptrAPI
		ea_api.append(ida_bytes.get_wide_dword(ptr_api_struct))
		# print(f"DWORD - 0x{offset_api:x}")
		ptr_api_struct = ida_bytes.next_head(ptr_api_struct, 0xffffffff)

		# offset in data[] to decrypt procname
		offsets.append(ida_bytes.get_wide_dword(ptr_api_struct))
		# print(f"PROC - 0x{offset_proc:x}")
		ptr_api_struct = ida_bytes.next_head(ptr_api_struct, 0xffffffff)

		# offset in data[] to decrypt modulename
		# needed for module validation
		offset_dll = ida_bytes.get_wide_dword(ptr_api_struct)
		# print(f"DLL - 0x{offset_dll:x}")
		ptr_api_struct = ida_bytes.next_head(ptr_api_struct, 0xffffffff)

	return ea_api, offsets

def main():

	dll_structs = [ 
					0x10024030,

					# probably not used but lets bulk resolve them all
					0x100243E0,
					]
	for dll in dll_structs:
		ea_api, offsets = iat_define(dll)
		for (ea, offset) in zip(ea_api, offsets):
			decrypted_api = string_decrypt(offset)

			if not set_name(ea, decrypted_api):
				set_name(ea, f"{decrypted_api}_0")